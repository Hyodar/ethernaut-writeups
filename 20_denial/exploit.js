
// since the call's gas isn't limited, we can spend the max we can
// (which is 1/64 of the available gas at the time of the call)
// and if the remaining gas isn't enough for the operations that
// follow the call, then withdraw() would be unsuccesful,
// even though it ignores the call's success.
//
// I did try some things like making an endless recursion
// and running an INVALID opcode but Remix IDE gas limit 
// was sufficiently high so that the the transaction wouldn't
// revert (and I didn't realize that was the reason until
// after I read a solution).
//
// so, this time I had other writeup's help, and turns out
// their solution was similar to what I had tried.
// we still consume all of the call gas, but more cleanly -
// through an assert(). a false assert, which is simply
// (or should be) an INVALID opcode, consumes all
// of the available gas, so we can just add one.
// however, if we try to compile this:
//
// contract DenialExploit {
//     fallback() external payable {
//         assert(false);
//     }
// }
//
// with a >0.8.5 solidity compiler, its resulting opcode wouldn't
// be just that of an assert (an INVALID opcode) - it would have
// a REVERT opcode before it.
//
// (https://ethereum.stackexchange.com/questions/107882/ethernaut-level-20-denial-probably-no-longer-solvable-why)
//
// we could use inline assembly or an older solidity compiler version
// to enforce this, but I did the entire contract in yul for fun.

const exploitAddr = "0x4B79c45B0cb83E1079195044e194C3cD74ebe1d4";

await contract.setWithdrawPartner(exploitAddr);
